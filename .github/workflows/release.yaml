name: Weekly Release Check and Update

on:
  schedule:
    # Run every Monday at 9:00 AM UTC
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allow manual triggering
    inputs:
      force_update:
        description: 'Force update even if version is the same'
        required: false
        default: false
        type: boolean
      target_version:
        description: 'Target specific version (leave empty for latest)'
        required: false
        type: string
      dry_run:
        description: 'Run without making changes (dry run)'
        required: false
        default: false
        type: boolean

env:
  REFERENCED_REPO: mahendrapaipuri/grafana-dashboard-reporter-app
  VALUES_FILE: grafana-pdf-report-app.values.yaml
  PLUGIN_NAME: mahendrapaipuri-dashboardreporter-app

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Show repository info
        run: |
          echo "Current working directory: $(pwd)"
          echo "Repository contents:"
          ls -la
          echo ""
          echo "Git status:"
          git status
          echo ""
          echo "Git remote:"
          git remote -v

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests semver
          
          # Install GitHub CLI
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Authenticate with GitHub CLI
        run: |
          echo "${{ github.token }}" | gh auth login --with-token
          
          # Verify authentication
          gh auth status
          echo "GitHub CLI authenticated successfully"

      - name: Get current version from values.yaml
        id: current-version
        run: |
          # Check if values.yaml exists
          if [ ! -f "${{ env.VALUES_FILE }}" ]; then
            echo "❌ Error: ${{ env.VALUES_FILE }} not found!"
            ls -la
            exit 1
          fi
          
          echo "✅ Found ${{ env.VALUES_FILE }}"
          echo "File contents (first 10 lines):"
          head -10 "${{ env.VALUES_FILE }}"
          echo ""
          
          # Extract current version from the plugin URL in values.yaml
          CURRENT_VERSION=$(grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' "${{ env.VALUES_FILE }}" | head -1 | sed 's/v//')
          
          if [ -z "$CURRENT_VERSION" ]; then
            echo "❌ Error: Could not extract version from ${{ env.VALUES_FILE }}"
            echo "File content:"
            cat "${{ env.VALUES_FILE }}"
            exit 1
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get latest release from referenced repository
        id: latest-release
        run: |
          # Check if manual target version is specified
          if [ "${{ github.event.inputs.target_version }}" != "" ]; then
            LATEST_TAG="${{ github.event.inputs.target_version }}"
            echo "Using manual target version: $LATEST_TAG"
          else
            # Get the latest release tag from the referenced repository
            echo "Fetching latest release from ${{ env.REFERENCED_REPO }}..."
            API_RESPONSE=$(curl -s "https://api.github.com/repos/${{ env.REFERENCED_REPO }}/releases/latest")
            
            if [ $? -ne 0 ]; then
              echo "❌ Error: Failed to fetch from GitHub API"
              exit 1
            fi
            
            LATEST_TAG=$(echo "$API_RESPONSE" | jq -r '.tag_name' | sed 's/v//')
            
            if [ "$LATEST_TAG" = "null" ] || [ -z "$LATEST_TAG" ]; then
              echo "❌ Error: Could not extract tag from API response"
              echo "API Response: $API_RESPONSE"
              exit 1
            fi
            
            echo "Latest release from repository: $LATEST_TAG"
          fi
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Target version: $LATEST_TAG"

      - name: Check if update is needed
        id: update-check
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          FORCE_UPDATE="${{ github.event.inputs.force_update }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          # Check if force update is requested
          if [ "$FORCE_UPDATE" = "true" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "Force update requested: $CURRENT -> $LATEST"
          else
            # Use semver to compare versions
            if python -c "import semver; exit(0 if semver.compare('$LATEST', '$CURRENT') > 0 else 1)"; then
              echo "update_needed=true" >> $GITHUB_OUTPUT
              echo "Update needed: $CURRENT -> $LATEST"
            else
              echo "update_needed=false" >> $GITHUB_OUTPUT
              echo "No update needed: $CURRENT >= $LATEST"
            fi
          fi
          
          # Set dry run flag
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

      - name: Check for existing pull requests
        if: steps.update-check.outputs.update_needed == 'true'
        id: existing-pr-check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          
          # Check if a PR already exists for this version
          echo "Checking for existing pull requests for version v$LATEST..."
          
          # Search for existing PRs with similar titles
          EXISTING_PR=$(gh pr list --search "update ${{ env.PLUGIN_NAME }} to v$LATEST" --json number,title,state --limit 10)
          
          if [ "$(echo "$EXISTING_PR" | jq -r '.[0].number // empty')" != "" ]; then
            echo "Found existing PR for version v$LATEST:"
            echo "$EXISTING_PR" | jq -r '.[] | "PR #\(.number): \(.title) (\(.state))"'
            
            # Check if any are open
            OPEN_PR=$(echo "$EXISTING_PR" | jq -r '.[] | select(.state == "OPEN") | .number' | head -1)
            
            if [ "$OPEN_PR" != "" ]; then
              echo "❌ Open PR #$OPEN_PR already exists for version v$LATEST"
              echo "existing_pr=$OPEN_PR" >> $GITHUB_OUTPUT
              echo "skip_update=true" >> $GITHUB_OUTPUT
            else
              echo "ℹ️  Found closed/merged PRs for version v$LATEST, proceeding with update"
              echo "skip_update=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "✅ No existing PRs found for version v$LATEST"
            echo "skip_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Update values.yaml if needed
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-pr-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            echo "DRY RUN: Would replace 'v$CURRENT' with 'v$LATEST' in ${{ env.VALUES_FILE }}"
            exit 0
          fi
          
          # Create backup
          cp ${{ env.VALUES_FILE }} ${{ env.VALUES_FILE }}.backup
          
          # Update the plugin URL in values.yaml
          sed -i "s|v$CURRENT|v$LATEST|g" ${{ env.VALUES_FILE }}
          
          # Verify the change
          if grep -q "v$LATEST" ${{ env.VALUES_FILE }}; then
            echo "Successfully updated to version v$LATEST"
          else
            echo "Failed to update version"
            exit 1
          fi

      - name: Create pull request for update
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-pr-check.outputs.skip_update != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would create pull request for update from v$CURRENT to v$LATEST"
            echo "DRY RUN: Would create branch: update-plugin-to-v$LATEST"
            exit 0
          fi
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Ensure we're on main branch and it's up to date
          echo "Ensuring we're on main branch and it's up to date..."
          git checkout main
          git pull origin main
          
          # Create unique branch name with timestamp to avoid conflicts
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="update-plugin-to-v$LATEST-$TIMESTAMP"
          echo "Creating branch: $BRANCH_NAME"
          
          # Clean up any existing branches for this version to avoid conflicts
          echo "Cleaning up existing branches for version v$LATEST..."
          EXISTING_BRANCHES=$(git branch -r | grep "update-plugin-to-v$LATEST" || true)
          
          if [ -n "$EXISTING_BRANCHES" ]; then
            echo "Found existing branches:"
            echo "$EXISTING_BRANCHES"
            
            # Delete remote branches
            for branch in $EXISTING_BRANCHES; do
              BRANCH_NAME_SHORT=$(echo "$branch" | sed 's/origin\///')
              echo "Deleting remote branch: $BRANCH_NAME_SHORT"
              git push origin --delete "$BRANCH_NAME_SHORT" || true
            done
          fi
          
          # Check if our specific branch already exists remotely and delete it if it does
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists remotely, deleting it..."
            git push origin --delete "$BRANCH_NAME" || true
          fi
          
          # Create and switch to new branch
          git checkout -b "$BRANCH_NAME"
          
          # Add changes
          git add ${{ env.VALUES_FILE }}
          
          # Commit changes
          git commit -m "feat: update ${{ env.PLUGIN_NAME }} from v$CURRENT to v$LATEST
          
          - Updated plugin download URL to latest release
          - Automated update via GitHub Actions
          - Release: https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST
          - Branch: $BRANCH_NAME"
          
          # Push branch with force to ensure it works
          echo "Pushing branch $BRANCH_NAME..."
          git push origin "$BRANCH_NAME" --force
          
          if [ $? -ne 0 ]; then
            echo "❌ Failed to push branch"
            exit 1
          fi
          
          echo "✅ Branch pushed successfully"
          
          # Wait a moment for the branch to be available
          sleep 5
          
          # Create pull request using GitHub CLI
          echo "Creating pull request..."
          PR_URL=$(gh pr create \
            --title "feat: update ${{ env.PLUGIN_NAME }} to v$LATEST" \
            --body "## Automated Plugin Update
          
          This PR updates the ${{ env.PLUGIN_NAME }} plugin from v$CURRENT to v$LATEST.
          
          ### Changes
          - Updated plugin download URL in \`${{ env.VALUES_FILE }}\`
          - Automated update via weekly GitHub Actions workflow
          - Branch: \`$BRANCH_NAME\`
          
          ### Release Notes
          - [v$LATEST Release](https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST)
          
          ### Testing
          - [ ] Verify the new plugin version works correctly
          - [ ] Test PDF report generation functionality
          - [ ] Ensure no breaking changes in configuration
          
          ### Automated by
          - Weekly release check workflow
          - Triggered: ${{ github.event_name }}" \
            --base main \
            --head "$BRANCH_NAME")
          
          if [ $? -eq 0 ]; then
            echo "✅ Pull request created successfully: $PR_URL"
          else
            echo "❌ Failed to create pull request"
            exit 1
          fi

      - name: Create GitHub release
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-pr-check.outputs.skip_update != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would create GitHub release v$LATEST"
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            exit 0
          fi
          
          # Create release notes
          RELEASE_NOTES="## ${{ env.PLUGIN_NAME }} Plugin Update v$LATEST
          
          ### What's New
          - Updated plugin from v$CURRENT to v$LATEST
          - Latest features and bug fixes from upstream
          
          ### Changes
          - Updated \`${{ env.VALUES_FILE }}\` with new plugin version
          - Plugin download URL now points to v$LATEST release
          
          ### Files Updated
          - \`${{ env.VALUES_FILE }}\` - Plugin version updated
          
          ### Upstream Release
          - [v$LATEST Release Notes](https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST)
          
          ### Installation
          Use the updated \`${{ env.VALUES_FILE }}\` file with your kube-prometheus-stack deployment.
          
          ### Breaking Changes
          None detected - this is a version bump update.
          
          ---
          *This release was automatically generated by GitHub Actions*"
          
          # Create release using GitHub CLI
          echo "Creating GitHub release..."
          RELEASE_URL=$(gh release create "v$LATEST" \
            --title "Plugin Update v$LATEST" \
            --notes "$RELEASE_NOTES" \
            --target main \
            --latest)
          
          if [ $? -eq 0 ]; then
            echo "✅ GitHub release created successfully: $RELEASE_URL"
          else
            echo "❌ Failed to create GitHub release"
            exit 1
          fi

      - name: Comment on PR if no update needed
        if: steps.update-check.outputs.update_needed == 'false'
        run: |
          echo "No update needed. Current version (${{ steps.current-version.outputs.current_version }}) is up to date."
          echo "Latest available version: ${{ steps.latest-release.outputs.latest_tag }}"

      - name: Handle existing PR case
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-pr-check.outputs.skip_update == 'true'
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          EXISTING_PR="${{ steps.existing-pr-check.outputs.existing_pr }}"
          
          echo "ℹ️  Skipping update to v$LATEST because open PR #$EXISTING_PR already exists"
          echo "You can review and merge the existing PR instead of creating a duplicate"

      - name: Workflow Summary
        if: always()
        run: |
          echo "## Workflow Summary"
          echo "=================="
          echo "Current version: ${{ steps.current-version.outputs.current_version }}"
          echo "Target version: ${{ steps.latest-release.outputs.latest_tag }}"
          echo "Update needed: ${{ steps.update-check.outputs.update_needed }}"
          echo "Dry run: ${{ steps.update-check.outputs.dry_run }}"
          echo "Force update: ${{ github.event.inputs.force_update }}"
          echo "Manual target: ${{ github.event.inputs.target_version }}"
          
          if [ "${{ steps.update-check.outputs.update_needed }}" = "true" ]; then
            if [ "${{ steps.existing-pr-check.outputs.skip_update }}" = "true" ]; then
              echo "ℹ️  SKIPPED: Update to v${{ steps.latest-release.outputs.latest_tag }} skipped due to existing PR #${{ steps.existing-pr-check.outputs.existing_pr }}"
            elif [ "${{ steps.update-check.outputs.dry_run }}" = "true" ]; then
              echo "✅ DRY RUN: Would have updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
            else
              echo "✅ SUCCESS: Updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
            fi
          else
            echo "ℹ️  No update needed - current version is up to date"
          fi

      - name: Cleanup
        if: always()
        run: |
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: No cleanup needed"
            exit 0
          fi
          
          # Remove backup file if it exists
          if [ -f "${{ env.VALUES_FILE }}.backup" ]; then
            rm "${{ env.VALUES_FILE }}.backup"
          fi
