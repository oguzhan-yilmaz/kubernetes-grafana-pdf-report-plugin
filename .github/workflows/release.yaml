name: Weekly Release Check and Update

on:
  schedule:
    # Run every Monday at 9:00 AM UTC
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allow manual triggering
    inputs:
      force_update:
        description: 'Force update even if version is the same'
        required: false
        default: false
        type: boolean
      target_version:
        description: 'Target specific version (leave empty for latest)'
        required: false
        type: string
      dry_run:
        description: 'Run without making changes (dry run)'
        required: false
        default: false
        type: boolean

env:
  REFERENCED_REPO: mahendrapaipuri/grafana-dashboard-reporter-app
  VALUES_FILE: grafana-pdf-report-app.values.yaml
  PLUGIN_NAME: mahendrapaipuri-dashboardreporter-app

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Show repository info
        run: |
          echo "Current working directory: $(pwd)"
          echo "Repository contents:"
          ls -la
          echo ""
          echo "Git status:"
          git status
          echo ""
          echo "Git remote:"
          git remote -v

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests semver
          
          # Ensure curl and jq are available
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          type -p jq >/dev/null || (sudo apt update && sudo apt install jq -y)
          
          echo "Dependencies installed:"
          echo "Python: $(python --version)"
          echo "curl: $(curl --version | head -1)"
          echo "jq: $(jq --version)"

      - name: Get current version from values.yaml
        id: current-version
        run: |
          # Check if values.yaml exists
          if [ ! -f "${{ env.VALUES_FILE }}" ]; then
            echo "❌ Error: ${{ env.VALUES_FILE }} not found!"
            ls -la
            exit 1
          fi
          
          echo "✅ Found ${{ env.VALUES_FILE }}"
          echo "File contents (first 10 lines):"
          head -10 "${{ env.VALUES_FILE }}"
          echo ""
          
          # Extract current version from the plugin URL in values.yaml
          CURRENT_VERSION=$(grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' "${{ env.VALUES_FILE }}" | head -1 | sed 's/v//')
          
          if [ -z "$CURRENT_VERSION" ]; then
            echo "❌ Error: Could not extract version from ${{ env.VALUES_FILE }}"
            echo "File content:"
            cat "${{ env.VALUES_FILE }}"
            exit 1
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get latest release from referenced repository
        id: latest-release
        run: |
          # Check if manual target version is specified
          if [ "${{ github.event.inputs.target_version }}" != "" ]; then
            LATEST_TAG="${{ github.event.inputs.target_version }}"
            echo "Using manual target version: $LATEST_TAG"
          else
            # Get the latest release tag from the referenced repository
            echo "Fetching latest release from ${{ env.REFERENCED_REPO }}..."
            API_RESPONSE=$(curl -s "https://api.github.com/repos/${{ env.REFERENCED_REPO }}/releases/latest")
            
            if [ $? -ne 0 ]; then
              echo "❌ Error: Failed to fetch from GitHub API"
              exit 1
            fi
            
            LATEST_TAG=$(echo "$API_RESPONSE" | jq -r '.tag_name' | sed 's/v//')
            
            if [ "$LATEST_TAG" = "null" ] || [ -z "$LATEST_TAG" ]; then
              echo "❌ Error: Could not extract tag from API response"
              echo "API Response: $API_RESPONSE"
              exit 1
            fi
            
            echo "Latest release from repository: $LATEST_TAG"
          fi
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Target version: $LATEST_TAG"

      - name: Check if update is needed
        id: update-check
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          FORCE_UPDATE="${{ github.event.inputs.force_update }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          # Check if force update is requested
          if [ "$FORCE_UPDATE" = "true" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "Force update requested: $CURRENT -> $LATEST"
          else
            # Use semver to compare versions
            if python -c "import semver; exit(0 if semver.compare('$LATEST', '$CURRENT') > 0 else 1)"; then
              echo "update_needed=true" >> $GITHUB_OUTPUT
              echo "Update needed: $CURRENT -> $LATEST"
            else
              echo "update_needed=false" >> $GITHUB_OUTPUT
              echo "No update needed: $CURRENT >= $LATEST"
            fi
          fi
          
          # Set dry run flag
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

      - name: Check for existing releases
        if: steps.update-check.outputs.update_needed == 'true'
        id: existing-release-check
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          
          # Check if a release already exists for this version
          echo "Checking for existing releases for version v$LATEST..."
          
          # Check if tag exists locally
          if git tag -l "v$LATEST" | grep -q "v$LATEST"; then
            echo "❌ Tag v$LATEST already exists locally"
            echo "skip_update=true" >> $GITHUB_OUTPUT
          else
            echo "✅ No existing tag found for version v$LATEST"
            echo "skip_update=false" >> $GITHUB_OUTPUT
          fi
          
          # Also check remote tags
          echo "Checking remote tags..."
          git ls-remote --tags origin | grep "v$LATEST" || echo "No remote tag found for v$LATEST"
          
          # Check GitHub API for existing releases
          echo "Checking GitHub API for existing releases..."
          RELEASES_RESPONSE=$(curl -s \
            -H "Authorization: token ${{ github.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=5")
          
          if [ $? -eq 0 ]; then
            RELEASE_COUNT=$(echo "$RELEASES_RESPONSE" | jq -r 'length')
            echo "Found $RELEASE_COUNT existing releases"
            if [ "$RELEASE_COUNT" -gt 0 ]; then
              echo "Recent releases:"
              echo "$RELEASES_RESPONSE" | jq -r '.[] | "- \(.tag_name): \(.name)"'
            fi
          else
            echo "Could not fetch releases (this is normal for first run)"
          fi

      - name: Update values.yaml if needed
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            echo "DRY RUN: Would replace 'v$CURRENT' with 'v$LATEST' in ${{ env.VALUES_FILE }}"
            exit 0
          fi
          
          # Create backup
          cp ${{ env.VALUES_FILE }} ${{ env.VALUES_FILE }}.backup
          
          # Update the plugin URL in values.yaml
          sed -i "s|v$CURRENT|v$LATEST|g" ${{ env.VALUES_FILE }}
          
          # Verify the change
          if grep -q "v$LATEST" ${{ env.VALUES_FILE }}; then
            echo "Successfully updated to version v$LATEST"
          else
            echo "Failed to update version"
            exit 1
          fi

      - name: Commit and tag update
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would commit and tag update from v$CURRENT to v$LATEST"
            exit 0
          fi
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Ensure we're on main branch
          echo "Ensuring we're on main branch..."
          git checkout main
          
          # Add and commit changes
          echo "Committing changes..."
          git add ${{ env.VALUES_FILE }}
          git commit -m "feat: update ${{ env.PLUGIN_NAME }} from v$CURRENT to v$LATEST
          
          - Updated plugin download URL to latest release
          - Automated update via GitHub Actions
          - Release: https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST"
          
          # Create and push tag
          echo "Creating tag v$LATEST..."
          git tag -a "v$LATEST" -m "Plugin update to v$LATEST"
          
          # Push changes and tag
          echo "Pushing changes and tag..."
          git push origin main
          git push origin "v$LATEST"
          
          if [ $? -eq 0 ]; then
            echo "✅ Changes committed and tag v$LATEST pushed successfully"
          else
            echo "❌ Failed to push changes or tag"
            exit 1
          fi

      - name: Create GitHub release
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would create GitHub release v$LATEST"
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            exit 0
          fi
          
          # Create release notes
          RELEASE_NOTES="## ${{ env.PLUGIN_NAME }} Plugin Update v$LATEST
          
          ### What's New
          - Updated plugin from v$CURRENT to v$LATEST
          - Latest features and bug fixes from upstream
          
          ### Changes
          - Updated \`${{ env.VALUES_FILE }}\` with new plugin version
          - Plugin download URL now points to v$LATEST release
          
          ### Files Updated
          - \`${{ env.VALUES_FILE }}\` - Plugin version updated
          
          ### Upstream Release
          - [v$LATEST Release Notes](https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST)
          
          ### Installation
          
          #### Option 1: Download from this release
          Download the \`${{ env.VALUES_FILE }}\` file from the **Assets** section below and use it with your kube-prometheus-stack deployment.
          
          #### Option 2: Use the raw file from main branch
          ```bash
          curl -O https://raw.githubusercontent.com/${{ github.repository }}/main/${{ env.VALUES_FILE }}
          ```
          
          #### Option 3: Use with Helm
          ```bash
          helm upgrade --install kube-prometheus-stack -n monitoring \
            -f grafana-default-values.yaml \
            -f ${{ env.VALUES_FILE }} \
            prometheus-community/kube-prometheus-stack
          ```
          
          ### Breaking Changes
          None detected - this is a version bump update.
          
          ---
          *This release was automatically generated by GitHub Actions*"
          
          # Create release using GitHub API directly (bypassing GitHub CLI)
          echo "Creating GitHub release via API..."
          
          API_RESPONSE=$(curl -s -X POST \
            -H "Authorization: token ${{ github.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            -d "{
              \"tag_name\": \"v$LATEST\",
              \"name\": \"Plugin Update v$LATEST\",
              \"body\": \"$RELEASE_NOTES\",
              \"target_commitish\": \"main\"
            }" \
            "https://api.github.com/repos/${{ github.repository }}/releases")
          
          if [ $? -eq 0 ]; then
            RELEASE_ID=$(echo "$API_RESPONSE" | jq -r '.id // empty')
            if [ "$RELEASE_ID" != "" ] && [ "$RELEASE_ID" != "null" ]; then
              RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/v$LATEST"
              echo "✅ GitHub release created successfully via API: $RELEASE_URL"
              echo "Release ID: $RELEASE_ID"
            else
              echo "❌ Failed to create release via API"
              echo "API Response: $API_RESPONSE"
              exit 1
            fi
          else
            echo "❌ Failed to create release via API"
            exit 1
          fi
          
          # Store release ID for asset upload
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT

      - name: Upload values.yaml as release asset
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would upload ${{ env.VALUES_FILE }} as release asset for v$LATEST"
            exit 0
          fi
          
          echo "Uploading ${{ env.VALUES_FILE }} as release asset..."
          
          # Get the release ID from the previous step
          RELEASE_ID="${{ steps.create-github-release.outputs.release_id }}"
          
          if [ -n "$RELEASE_ID" ]; then
            echo "Uploading via GitHub API..."
            UPLOAD_URL="https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets"
            
            # Upload the file
            UPLOAD_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${{ github.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@${{ env.VALUES_FILE }}" \
              "$UPLOAD_URL?name=${{ env.VALUES_FILE }}&label=${{ env.VALUES_FILE }}")
            
            if [ $? -eq 0 ]; then
              ASSET_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id // empty')
              if [ "$ASSET_ID" != "" ] && [ "$ASSET_ID" != "null" ]; then
                echo "✅ Successfully uploaded ${{ env.VALUES_FILE }} via API (Asset ID: $ASSET_ID)"
              else
                echo "❌ Failed to upload via API"
                echo "API Response: $UPLOAD_RESPONSE"
                exit 1
              fi
            else
              echo "❌ Failed to upload via API"
              exit 1
            fi
          else
            echo "❌ No release ID available for asset upload"
            exit 1
          fi

      - name: Verify release asset
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would verify release asset for v$LATEST"
            exit 0
          fi
          
          echo "Verifying release asset..."
          
          # Get the release ID from the previous step
          RELEASE_ID="${{ steps.create-github-release.outputs.release_id }}"
          
          if [ -n "$RELEASE_ID" ]; then
            # Check if the asset exists in the release using GitHub API
            ASSETS_RESPONSE=$(curl -s \
              -H "Authorization: token ${{ github.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID")
            
            if [ $? -eq 0 ]; then
              ASSET_COUNT=$(echo "$ASSETS_RESPONSE" | jq -r '.assets | length')
              if [ "$ASSET_COUNT" -gt 0 ]; then
                echo "✅ Release asset verified: $ASSET_COUNT asset(s) found in release v$LATEST"
                echo "Assets:"
                echo "$ASSETS_RESPONSE" | jq -r '.assets[] | "- \(.name) (\(.size) bytes)"'
              else
                echo "⚠️  No assets found in release, but this might be a timing issue"
                echo "The asset should appear shortly in the release"
              fi
            else
              echo "⚠️  Could not verify assets via API, but this might be a timing issue"
            fi
          else
            echo "⚠️  No release ID available for verification"
          fi

      - name: Comment on PR if no update needed
        if: steps.update-check.outputs.update_needed == 'false'
        run: |
          echo "No update needed. Current version (${{ steps.current-version.outputs.current_version }}) is up to date."
          echo "Latest available version: ${{ steps.latest-release.outputs.latest_tag }}"

      - name: Handle existing release case
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update == 'true'
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          
          echo "ℹ️  Skipping update to v$LATEST because tag v$LATEST already exists"
          echo "This version has already been released"

      - name: Workflow Summary
        if: always()
        run: |
          echo "## Workflow Summary"
          echo "=================="
          echo "Current version: ${{ steps.current-version.outputs.current_version }}"
          echo "Target version: ${{ steps.latest-release.outputs.latest_tag }}"
          echo "Update needed: ${{ steps.update-check.outputs.update_needed }}"
          echo "Dry run: ${{ steps.update-check.outputs.dry_run }}"
          echo "Force update: ${{ github.event.inputs.force_update }}"
          echo "Manual target: ${{ github.event.inputs.target_version }}"
          
          if [ "${{ steps.update-check.outputs.update_needed }}" = "true" ]; then
            if [ "${{ steps.existing-release-check.outputs.skip_update }}" = "true" ]; then
              echo "ℹ️  SKIPPED: Update to v${{ steps.latest-release.outputs.latest_tag }} skipped due to existing tag"
            elif [ "${{ steps.update-check.outputs.dry_run }}" = "true" ]; then
              echo "✅ DRY RUN: Would have updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
            else
              echo "✅ SUCCESS: Updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
              echo "✅ RELEASE: Created GitHub release v${{ steps.latest-release.outputs.latest_tag }}"
              echo "✅ ASSET: Uploaded ${{ env.VALUES_FILE }} as release asset"
            fi
          else
            echo "ℹ️  No update needed - current version is up to date"
          fi

      - name: Cleanup
        if: always()
        run: |
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: No cleanup needed"
            exit 0
          fi
          
          # Remove backup file if it exists
          if [ -f "${{ env.VALUES_FILE }}.backup" ]; then
            rm "${{ env.VALUES_FILE }}.backup"
          fi
