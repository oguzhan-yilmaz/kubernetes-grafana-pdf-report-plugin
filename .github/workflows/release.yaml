name: Weekly Release Check and Update

on:
  schedule:
    # Run every Monday at 9:00 AM UTC
    - cron: '0 9 * * 1'
  workflow_dispatch: # Allow manual triggering
    inputs:
      force_update:
        description: 'Force update even if version is the same'
        required: false
        default: false
        type: boolean
      target_version:
        description: 'Target specific version (leave empty for latest)'
        required: false
        type: string
      dry_run:
        description: 'Run without making changes (dry run)'
        required: false
        default: false
        type: boolean

env:
  REFERENCED_REPO: mahendrapaipuri/grafana-dashboard-reporter-app
  VALUES_FILE: grafana-pdf-report-app.values.yaml
  PLUGIN_NAME: mahendrapaipuri-dashboardreporter-app

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Show repository info
        run: |
          echo "Current working directory: $(pwd)"
          echo "Repository contents:"
          ls -la
          echo ""
          echo "Git status:"
          git status
          echo ""
          echo "Git remote:"
          git remote -v

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests semver
          
          # Install GitHub CLI
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Authenticate with GitHub CLI
        run: |
          echo "${{ github.token }}" | gh auth login --with-token
          
          # Verify authentication
          gh auth status
          echo "GitHub CLI authenticated successfully"

      - name: Get current version from values.yaml
        id: current-version
        run: |
          # Check if values.yaml exists
          if [ ! -f "${{ env.VALUES_FILE }}" ]; then
            echo "❌ Error: ${{ env.VALUES_FILE }} not found!"
            ls -la
            exit 1
          fi
          
          echo "✅ Found ${{ env.VALUES_FILE }}"
          echo "File contents (first 10 lines):"
          head -10 "${{ env.VALUES_FILE }}"
          echo ""
          
          # Extract current version from the plugin URL in values.yaml
          CURRENT_VERSION=$(grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+' "${{ env.VALUES_FILE }}" | head -1 | sed 's/v//')
          
          if [ -z "$CURRENT_VERSION" ]; then
            echo "❌ Error: Could not extract version from ${{ env.VALUES_FILE }}"
            echo "File content:"
            cat "${{ env.VALUES_FILE }}"
            exit 1
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get latest release from referenced repository
        id: latest-release
        run: |
          # Check if manual target version is specified
          if [ "${{ github.event.inputs.target_version }}" != "" ]; then
            LATEST_TAG="${{ github.event.inputs.target_version }}"
            echo "Using manual target version: $LATEST_TAG"
          else
            # Get the latest release tag from the referenced repository
            echo "Fetching latest release from ${{ env.REFERENCED_REPO }}..."
            API_RESPONSE=$(curl -s "https://api.github.com/repos/${{ env.REFERENCED_REPO }}/releases/latest")
            
            if [ $? -ne 0 ]; then
              echo "❌ Error: Failed to fetch from GitHub API"
              exit 1
            fi
            
            LATEST_TAG=$(echo "$API_RESPONSE" | jq -r '.tag_name' | sed 's/v//')
            
            if [ "$LATEST_TAG" = "null" ] || [ -z "$LATEST_TAG" ]; then
              echo "❌ Error: Could not extract tag from API response"
              echo "API Response: $API_RESPONSE"
              exit 1
            fi
            
            echo "Latest release from repository: $LATEST_TAG"
          fi
          
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Target version: $LATEST_TAG"

      - name: Check if update is needed
        id: update-check
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          FORCE_UPDATE="${{ github.event.inputs.force_update }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          # Check if force update is requested
          if [ "$FORCE_UPDATE" = "true" ]; then
            echo "update_needed=true" >> $GITHUB_OUTPUT
            echo "Force update requested: $CURRENT -> $LATEST"
          else
            # Use semver to compare versions
            if python -c "import semver; exit(0 if semver.compare('$LATEST', '$CURRENT') > 0 else 1)"; then
              echo "update_needed=true" >> $GITHUB_OUTPUT
              echo "Update needed: $CURRENT -> $LATEST"
            else
              echo "update_needed=false" >> $GITHUB_OUTPUT
              echo "No update needed: $CURRENT >= $LATEST"
            fi
          fi
          
          # Set dry run flag
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

      - name: Check for existing releases
        if: steps.update-check.outputs.update_needed == 'true'
        id: existing-release-check
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          
          # Check if a release already exists for this version
          echo "Checking for existing releases for version v$LATEST..."
          
          # Check if tag exists locally
          if git tag -l "v$LATEST" | grep -q "v$LATEST"; then
            echo "❌ Tag v$LATEST already exists locally"
            echo "skip_update=true" >> $GITHUB_OUTPUT
          else
            echo "✅ No existing tag found for version v$LATEST"
            echo "skip_update=false" >> $GITHUB_OUTPUT
          fi

      - name: Update values.yaml if needed
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            echo "DRY RUN: Would replace 'v$CURRENT' with 'v$LATEST' in ${{ env.VALUES_FILE }}"
            exit 0
          fi
          
          # Create backup
          cp ${{ env.VALUES_FILE }} ${{ env.VALUES_FILE }}.backup
          
          # Update the plugin URL in values.yaml
          sed -i "s|v$CURRENT|v$LATEST|g" ${{ env.VALUES_FILE }}
          
          # Verify the change
          if grep -q "v$LATEST" ${{ env.VALUES_FILE }}; then
            echo "Successfully updated to version v$LATEST"
          else
            echo "Failed to update version"
            exit 1
          fi

      - name: Commit and tag update
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would commit and tag update from v$CURRENT to v$LATEST"
            exit 0
          fi
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Ensure we're on main branch
          echo "Ensuring we're on main branch..."
          git checkout main
          
          # Add and commit changes
          echo "Committing changes..."
          git add ${{ env.VALUES_FILE }}
          git commit -m "feat: update ${{ env.PLUGIN_NAME }} from v$CURRENT to v$LATEST
          
          - Updated plugin download URL to latest release
          - Automated update via GitHub Actions
          - Release: https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST"
          
          # Create and push tag
          echo "Creating tag v$LATEST..."
          git tag -a "v$LATEST" -m "Plugin update to v$LATEST"
          
          # Push changes and tag
          echo "Pushing changes and tag..."
          git push origin main
          git push origin "v$LATEST"
          
          if [ $? -eq 0 ]; then
            echo "✅ Changes committed and tag v$LATEST pushed successfully"
          else
            echo "❌ Failed to push changes or tag"
            exit 1
          fi

      - name: Create GitHub release
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: Would create GitHub release v$LATEST"
            echo "DRY RUN: Would update from v$CURRENT to v$LATEST"
            exit 0
          fi
          
          # Create release notes
          RELEASE_NOTES="## ${{ env.PLUGIN_NAME }} Plugin Update v$LATEST
          
          ### What's New
          - Updated plugin from v$CURRENT to v$LATEST
          - Latest features and bug fixes from upstream
          
          ### Changes
          - Updated \`${{ env.VALUES_FILE }}\` with new plugin version
          - Plugin download URL now points to v$LATEST release
          
          ### Files Updated
          - \`${{ env.VALUES_FILE }}\` - Plugin version updated
          
          ### Upstream Release
          - [v$LATEST Release Notes](https://github.com/${{ env.REFERENCED_REPO }}/releases/tag/v$LATEST)
          
          ### Installation
          Use the updated \`${{ env.VALUES_FILE }}\` file with your kube-prometheus-stack deployment.
          
          ### Breaking Changes
          None detected - this is a version bump update.
          
          ---
          *This release was automatically generated by GitHub Actions*"
          
          # Create release using GitHub CLI
          echo "Creating GitHub release..."
          RELEASE_URL=$(gh release create "v$LATEST" \
            --title "Plugin Update v$LATEST" \
            --notes "$RELEASE_NOTES" \
            --target main \
            --latest)
          
          if [ $? -eq 0 ]; then
            echo "✅ GitHub release created successfully: $RELEASE_URL"
          else
            echo "⚠️  GitHub CLI failed, trying GitHub API fallback..."
            
            # Fallback: Create release using GitHub API directly
            echo "Creating release via GitHub API..."
            API_RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${{ github.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              -d "{
                \"tag_name\": \"v$LATEST\",
                \"name\": \"Plugin Update v$LATEST\",
                \"body\": \"$RELEASE_NOTES\",
                \"target_commitish\": \"main\"
              }" \
              "https://api.github.com/repos/${{ github.repository }}/releases")
            
            if [ $? -eq 0 ]; then
              RELEASE_ID=$(echo "$API_RESPONSE" | jq -r '.id // empty')
              if [ "$RELEASE_ID" != "" ] && [ "$RELEASE_ID" != "null" ]; then
                RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/v$LATEST"
                echo "✅ GitHub release created successfully via API: $RELEASE_URL"
              else
                echo "❌ Failed to create release via API"
                echo "API Response: $API_RESPONSE"
                exit 1
              fi
            else
              echo "❌ Failed to create release via API"
              exit 1
            fi
          fi

      - name: Comment on PR if no update needed
        if: steps.update-check.outputs.update_needed == 'false'
        run: |
          echo "No update needed. Current version (${{ steps.current-version.outputs.current_version }}) is up to date."
          echo "Latest available version: ${{ steps.latest-release.outputs.latest_tag }}"

      - name: Handle existing release case
        if: steps.update-check.outputs.update_needed == 'true' && steps.existing-release-check.outputs.skip_update == 'true'
        run: |
          LATEST="${{ steps.latest-release.outputs.latest_tag }}"
          
          echo "ℹ️  Skipping update to v$LATEST because tag v$LATEST already exists"
          echo "This version has already been released"

      - name: Workflow Summary
        if: always()
        run: |
          echo "## Workflow Summary"
          echo "=================="
          echo "Current version: ${{ steps.current-version.outputs.current_version }}"
          echo "Target version: ${{ steps.latest-release.outputs.latest_tag }}"
          echo "Update needed: ${{ steps.update-check.outputs.update_needed }}"
          echo "Dry run: ${{ steps.update-check.outputs.dry_run }}"
          echo "Force update: ${{ github.event.inputs.force_update }}"
          echo "Manual target: ${{ github.event.inputs.target_version }}"
          
          if [ "${{ steps.update-check.outputs.update_needed }}" = "true" ]; then
            if [ "${{ steps.existing-release-check.outputs.skip_update }}" = "true" ]; then
              echo "ℹ️  SKIPPED: Update to v${{ steps.latest-release.outputs.latest_tag }} skipped due to existing tag"
            elif [ "${{ steps.update-check.outputs.dry_run }}" = "true" ]; then
              echo "✅ DRY RUN: Would have updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
            else
              echo "✅ SUCCESS: Updated from v${{ steps.current-version.outputs.current_version }} to v${{ steps.latest-release.outputs.latest_tag }}"
            fi
          else
            echo "ℹ️  No update needed - current version is up to date"
          fi

      - name: Cleanup
        if: always()
        run: |
          DRY_RUN="${{ steps.update-check.outputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "DRY RUN: No cleanup needed"
            exit 0
          fi
          
          # Remove backup file if it exists
          if [ -f "${{ env.VALUES_FILE }}.backup" ]; then
            rm "${{ env.VALUES_FILE }}.backup"
          fi
